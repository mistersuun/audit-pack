"""AR Summary PDF Parser for GEAC/UX PMS System.

Parses the AR Summary report (arsum) generated by GEAC/UX PMS system
at Sheraton Laval for night audit reconciliation.

The AR Summary is a single-page PDF containing:
- A/R Ledger Balance tracking
- Front Office Transfers
- Adjustments
- Invoices, Payments, Credit Card Charges, Service Charges
- Balance validation

The PDF text is positioned with values BEFORE their labels:
22,194,423.95 Day Previous - Balance Ledger A/R  [not: A/R Ledger Balance Previous Day 22,194,423.95]
4,064.49 Folios Guest                              [not: Guest Folios 4,064.49]
"""

import re
import pdfplumber
from io import BytesIO
from utils.parsers.base_parser import BaseParser


class ARSummaryParser(BaseParser):
    """Parser for AR Summary reports from GEAC/UX PMS."""

    FIELD_MAPPINGS = {
        'ar_previous_balance': 'B6',
        'ar_end_of_day': 'B7',
        'ar_transfers': 'B8',
    }

    def __init__(self, file_bytes, filename=None):
        super().__init__(file_bytes, filename)
        self.raw_text = None
        self.lines = []
        self.text_normalized = None

    def parse(self):
        """Parse AR Summary PDF and extract structured data."""
        try:
            # Extract text from PDF
            self.raw_text = self._extract_text_from_pdf()
            self.lines = [line.strip() for line in self.raw_text.split('\n')]
            self.text_normalized = re.sub(r'\s+', ' ', self.raw_text)

            # Parse all values
            self.extracted_data = {
                'report_date': self._extract_report_date(),
                'auditor': self._extract_auditor(),
                'report_generated': self._extract_report_generated(),
                'ar_balance_previous': self._extract_ar_balance_previous(),
                'front_office_transfers': self._extract_front_office_transfers(),
                'adjustments': self._extract_adjustments(),
                'invoices': self._extract_invoices(),
                'payments': self._extract_payments(),
                'ar_credit_card_charges': self._extract_ar_credit_card_charges(),
                'service_charges': self._extract_service_charges(),
                'ar_balance_end_of_day': self._extract_ar_balance_end_of_day(),
            }

            # Add validation and RJ mapping
            self.extracted_data['balanced'] = self._validate_balance()
            self.extracted_data['rj_mapping'] = self._build_rj_mapping()

            # Set confidence based on successful parsing
            self.confidence = 0.95 if self.extracted_data['balanced'] else 0.70
            self._parsed = True

        except Exception as e:
            self.validation_errors.append(f"Parse error: {str(e)}")
            self.confidence = 0.0
            self._parsed = True

    def validate(self):
        """Validate extracted data."""
        is_valid = True

        # Check required fields
        required_fields = [
            'ar_balance_previous',
            'ar_balance_end_of_day',
            'front_office_transfers',
            'adjustments',
        ]

        for field in required_fields:
            if field not in self.extracted_data or self.extracted_data[field] is None:
                self.validation_errors.append(f"Missing required field: {field}")
                is_valid = False

        # Validate balance equation
        if not self.extracted_data.get('balanced', False):
            self.validation_warnings.append(
                "Balance validation failed: "
                "ar_previous + transfers + adjustments + invoices + payments + cc_charges + service != ar_eod"
            )

        # Check for non-zero values in expected fields
        if self.extracted_data.get('ar_balance_previous', 0) == 0:
            self.validation_warnings.append("A/R Previous Balance is zero")

        if self.extracted_data.get('ar_balance_end_of_day', 0) == 0:
            self.validation_warnings.append("A/R End of Day Balance is zero")

        return is_valid

    def _extract_text_from_pdf(self):
        """Extract text from PDF using pdfplumber."""
        text = ""
        try:
            with pdfplumber.open(BytesIO(self.file_bytes)) as pdf:
                for page in pdf.pages:
                    text += page.extract_text() or ""
        except Exception as e:
            raise Exception(f"Failed to extract text from PDF: {str(e)}")

        # The PDF text is reversed (right-to-left), so normalize it
        return self._normalize_text(text)

    def _normalize_text(self, text):
        """Normalize reversed/mirrored text by reversing each line."""
        # Check if text appears to be backwards (contains "yrammuS" instead of "Summary")
        if 'yrammuS' in text or 'ecnalaB' in text:
            # Text is backwards, reverse each line
            lines = text.split('\n')
            normalized_lines = [line[::-1] for line in lines]
            text = '\n'.join(normalized_lines)

        return text

    def _find_value_by_label_sequence(self, *label_keywords):
        """Find a numeric value that appears BEFORE a sequence of label keywords.

        This method looks for: NUMBER ... KEYWORD1 ... KEYWORD2 ... KEYWORD3
        and returns the NUMBER.

        The strategy: try multiple pattern variations to find the label sequence,
        then look backward for the nearest number.

        Args:
            label_keywords: One or more keywords that identify the field

        Returns:
            float: The extracted numeric value, or 0.0 if not found
        """
        # Build pattern to find the label sequence
        escaped_keywords = [re.escape(kw) for kw in label_keywords]

        # Try different joining patterns
        patterns_to_try = [
            r'\s+'.join(escaped_keywords),  # Keyword1 + Keyword2 + Keyword3
            r'[\s\-]+'.join(escaped_keywords),  # Allow dashes between keywords
            r'[\s\-]+.*?[\s\-]+'.join(escaped_keywords),  # Allow words between keywords
        ]

        match = None
        for pattern in patterns_to_try:
            match = re.search(pattern, self.text_normalized, re.IGNORECASE)
            if match:
                break

        if not match:
            return 0.0

        # Look backward from the label match to find the nearest number
        label_start = match.start()

        # Use a smaller search window by default (80 chars), with fallback to larger window
        # This prevents matching numbers from previous sections that happen to be in the
        # 200-char window
        text_before_label = self.text_normalized[max(0, label_start - 80):label_start]
        number_matches = list(re.finditer(r'[\d,]+\.?\d*', text_before_label))

        if not number_matches:
            # Fallback to larger window if nothing found
            text_before_label = self.text_normalized[max(0, label_start - 200):label_start]
            number_matches = list(re.finditer(r'[\d,]+\.?\d*', text_before_label))

        if number_matches:
            # Get the LAST number in the window (closest to the label)
            last_match = number_matches[-1]
            value_str = last_match.group(0)
            return self._safe_float(value_str)

        return 0.0

    def _extract_report_date(self):
        """Extract report date from scattered header components.

        The PDF structure has date parts scattered:
        "04, February Wednesday Audit Night"
        So we need to extract day-of-week, month, and date separately.
        """
        # Extract the day of week (Wednesday, Thursday, etc.)
        day_match = re.search(r'(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)', self.text_normalized, re.IGNORECASE)
        day_of_week = day_match.group(1) if day_match else None

        # Extract the month
        month_match = re.search(r'(January|February|March|April|May|June|July|August|September|October|November|December)', self.text_normalized, re.IGNORECASE)
        month = month_match.group(1) if month_match else None

        # Extract the date and year as: "04, February" or "04 February"
        date_match = re.search(r'(\d{1,2}),?\s+(?:January|February|March|April|May|June|July|August|September|October|November|December)', self.text_normalized, re.IGNORECASE)
        date_num = date_match.group(1) if date_match else None

        # Extract the year
        year_match = re.search(r'(20\d{2})', self.text_normalized)
        year = year_match.group(1) if year_match else None

        # Build the date string
        if day_of_week and month and date_num and year:
            return f"{day_of_week} {month} {date_num}, {year}"
        elif month and date_num and year:
            return f"{month} {date_num}, {year}"

        return None

    def _extract_auditor(self):
        """Extract auditor name from header.

        Due to PDF text extraction, the name appears as "Camara Souleymane"
        but should be returned as "Souleymane Camara".
        """
        # Look for a name pattern: Capitalized-Capitalized
        # The auditor name appears before "(arsum)"
        match = re.search(r'([A-Z][a-z]+)\s+([A-Z][a-z]+)\s+\(arsum\)', self.text_normalized, re.IGNORECASE)
        if match:
            last_name, first_name = match.groups()
            name_combined = f"{first_name} {last_name}".strip()
            # Make sure it's not a header/location word
            if not any(word in name_combined for word in ['Sheraton', 'Laval', 'Summary', 'Night', 'Page', 'Wednesday', 'February', 'Report', 'Number']):
                return name_combined

        # Fallback: look for any name-like pattern that's not a known header word
        for line in self.lines:
            stripped = line.strip()
            if re.match(r'^[A-Z][a-z]+\s+[A-Z][a-z]+$', stripped):
                if not any(word in stripped for word in ['Sheraton', 'Laval', 'Summary', 'Night', 'Page', 'Wednesday', 'February', 'Report']):
                    return stripped

        return None

    def _extract_report_generated(self):
        """Extract report generation timestamp (DD-MMM-YYYY HH:MM AM/PM)."""
        # Look for the complete timestamp pattern
        match = re.search(r'(\d{2}-[A-Z]{3}-\d{4}\s+\d{2}:\d{2}\s+[AP]M)', self.raw_text)
        if match:
            return match.group(1).strip()

        # Fallback: construct from separate components
        date_match = re.search(r'(\d{2}-[A-Z]{3}-\d{4})', self.raw_text)
        time_match = re.search(r'(\d{2}:\d{2})', self.raw_text)
        am_pm_match = re.search(r'(AM|PM)', self.raw_text)

        if date_match and time_match and am_pm_match:
            return f"{date_match.group(1)} {time_match.group(1)} {am_pm_match.group(1)}"

        return None

    def _extract_ar_balance_previous(self):
        """Extract A/R Ledger Balance - Previous Day.

        Pattern in text: "22,194,423.95 Day Previous - Balance Ledger A/R"
        """
        return self._find_value_by_label_sequence('Day', 'Previous', 'Balance', 'Ledger', 'A/R')

    def _extract_front_office_transfers(self):
        """Extract all Front Office Transfer line items."""
        return {
            'guest_folios': self._find_value_by_label_sequence('Folios', 'Guest'),
            'non_guest_folios': self._find_value_by_label_sequence('Folios', 'Non-Guest'),
            'subtotal': self._find_value_by_label_sequence('Subtotal'),
            'advance_deposits_cancel_dna': self._find_value_by_label_sequence('Cancel', 'DNA', 'Deposits', 'Advance'),
            'credit_cards': self._find_value_by_label_sequence('Cards', 'Credit'),
            'total': self._find_value_by_label_sequence('Transfers', 'Total'),
        }

    def _extract_adjustments(self):
        """Extract Adjustments line items."""
        # Special handling for Total Adjustments since the label appears after the values
        # and our normal search gets confused by the Transfers section values.
        # Look for pattern: Debits ... number ... Adjustments
        adjustments_total = 0.0

        # Find text between "Debits" and "Adjustments Total"
        debits_match = re.search(r'Debits', self.text_normalized, re.IGNORECASE)
        total_adj_match = re.search(r'Total\s+Adjustments', self.text_normalized, re.IGNORECASE)

        if debits_match and total_adj_match:
            # Get text between Debits and Total Adjustments
            between_text = self.text_normalized[debits_match.end():total_adj_match.start()]
            # Extract the last number in this section
            numbers = re.findall(r'[\d,]+\.?\d*', between_text)
            if numbers:
                adjustments_total = self._safe_float(numbers[-1])
        else:
            # Fallback to normal method
            adjustments_total = self._find_value_by_label_sequence('Total', 'Adjustments')

        return {
            'credits': self._find_value_by_label_sequence('Credits'),
            'debits': self._find_value_by_label_sequence('Debits'),
            'total': adjustments_total,
        }

    def _extract_invoices(self):
        """Extract Invoices value."""
        return self._find_value_by_label_sequence('Invoices')

    def _extract_payments(self):
        """Extract Payments value."""
        return self._find_value_by_label_sequence('Payments')

    def _extract_ar_credit_card_charges(self):
        """Extract A/R Credit Card Charges value."""
        return self._find_value_by_label_sequence('Charges', 'Card', 'Credit', 'A/R')

    def _extract_service_charges(self):
        """Extract Service Charges value."""
        return self._find_value_by_label_sequence('Charges', 'Service')

    def _extract_ar_balance_end_of_day(self):
        """Extract A/R Ledger Balance - End of Day.

        Pattern in text: "22,198,488.44 Day of End - Balance Ledger A/R"
        """
        return self._find_value_by_label_sequence('Day', 'of', 'End', 'Balance', 'Ledger', 'A/R')

    def _validate_balance(self):
        """
        Validate that the balance equation holds:
        ar_previous + transfers + adjustments + invoices + payments + cc_charges + service_charges = ar_eod

        Allow for small floating-point rounding errors (< 0.01).
        """
        previous = self.extracted_data.get('ar_balance_previous', 0.0)
        eod = self.extracted_data.get('ar_balance_end_of_day', 0.0)

        transfers_total = self.extracted_data.get('front_office_transfers', {}).get('total', 0.0)
        adjustments_total = self.extracted_data.get('adjustments', {}).get('total', 0.0)
        invoices = self.extracted_data.get('invoices', 0.0)
        payments = self.extracted_data.get('payments', 0.0)
        cc_charges = self.extracted_data.get('ar_credit_card_charges', 0.0)
        service_charges = self.extracted_data.get('service_charges', 0.0)

        calculated = previous + transfers_total + adjustments_total + invoices + payments + cc_charges + service_charges

        # Allow for floating-point rounding errors
        tolerance = 0.01
        is_balanced = abs(calculated - eod) < tolerance

        return is_balanced

    def _build_rj_mapping(self):
        """Build pre-computed RJ mapping for auto-fill."""
        return {
            'geac_ux': {
                'ar_previous_balance': self.extracted_data.get('ar_balance_previous', 0.0),
                'ar_end_of_day': self.extracted_data.get('ar_balance_end_of_day', 0.0),
                'ar_transfers': self.extracted_data.get('front_office_transfers', {}).get('total', 0.0),
            }
        }
